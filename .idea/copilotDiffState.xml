<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="updatedContent" value="# YOLO Image Labeling Tool&#10;&#10;YOLO Image Labeling Tool is a graphical application for labeling images with bounding boxes and class information, supporting YOLO format. It is designed for fast annotation, easy navigation, and efficient workflow for computer vision datasets.&#10;&#10;## 주요 기능&#10;&#10;- **이미지 폴더/단일 파일 불러오기**: 여러 이미지를 한 번에 불러와서 빠르게 라벨링 가능&#10;- **바운딩 박스 생성/삭제/수정**: 마우스로 드래그하여 박스 생성, 리스트/캔버스에서 삭제&#10;- **클래스 관리**: 클래스 추가/수정, 라벨별 클래스 선택&#10;- **자동 저장 모드**: 다음/이전 이미지 이동 시 자동으로 라벨 및 회전 정보 저장&#10;- **이미지 회전**: 90도 단위 및 마우스 드래그로 섬세하게 회전&#10;- **썸네일 사이드바**: 이미지 썸네일을 스크롤/키보드/트랙패드로 탐색 가능&#10;- **라벨 텍스트 파일 자동 관리**: 라벨 삭제 시 txt 파일도 자동 삭제&#10;&#10;## 설치 방법&#10;&#10;1. **Python 3.8 이상 설치**&#10;2. **필수 패키지 설치**&#10;&#10;```bash&#10;pip install -r requirements.txt&#10;```&#10;&#10;3. **프로젝트 다운로드**&#10;&#10;```bash&#10;git clone https://github.com/yourusername/YOLO-Image-Labeling-Tool.git&#10;cd YOLO-Image-Labeling-Tool&#10;```&#10;&#10;## 실행 방법&#10;&#10;```bash&#10;python labelling.py&#10;```&#10;&#10;## 사용법&#10;&#10;### 기본 라벨링&#10;- 이미지를 불러오면 캔버스에 표시됩니다.&#10;- 마우스로 드래그하여 바운딩 박스 생성&#10;- 클래스 선택 후 박스 생성 시 해당 클래스가 할당됨&#10;- 박스 위 텍스트로 클래스명 표시&#10;- 박스 삭제: 캔버스에서 마우스 오른쪽 버튼 클릭 또는 라벨 리스트에서 더블 클릭&#10;&#10;### 이미지 탐색&#10;- **이전/다음**: 하단 버튼 또는 좌/우 방향키&#10;- **썸네일 사이드바**: 마우스 휠, 트랙패드 두 손가락 스와이프, 위/아래 방향키, 스크롤 바로 탐색&#10;&#10;### 자동 저장 모드&#10;- 우측 '자동 저장 모드' 체크박스 활성화 시, 이미지 이동 시 라벨 및 회전 정보 자동 저장&#10;- 라벨이 모두 삭제되면 txt 파일도 자동 삭제&#10;&#10;### 이미지 회전&#10;- 우측 회전 버튼(왼쪽/오른쪽 90도)&#10;- 캔버스에서 마우스 드래그로 섬세하게 회전&#10;&#10;### 클래스 관리&#10;- '클래스 설정' 버튼 클릭 후 텍스트로 클래스명 입력 및 저장&#10;&#10;## 단축키&#10;&#10;| 기능                | 단축키           |&#10;|---------------------|------------------|&#10;| 이전 이미지         | ← (Left Arrow)   |&#10;| 다음 이미지         | → (Right Arrow)  |&#10;| 라벨링 모드 전환    | W                |&#10;| 회전 모드 전환      | R                |&#10;| 썸네일 스크롤       | ↑/↓, 마우스 휠, 트랙패드, 스크롤 바 |&#10;&#10;## 라벨 파일 포맷&#10;- 각 이미지와 동일한 이름의 .txt 파일에 저장&#10;- 각 줄: `class_id x_center y_center width height` (YOLO format, float)&#10;&#10;## 개발 및 기여&#10;- 이 저장소는 누구나 자유롭게 포크/기여할 수 있습니다.&#10;- 버그/기능 요청은 이슈로 남겨주세요.&#10;&#10;## 라이선스&#10;MIT License&#10;&#10;---&#10;문의: your.email@example.com&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/labeling_utils.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/labeling_utils.py" />
              <option name="originalContent" value="import tkinter as tk&#10;&#10;class LabelingUtils:&#10;    def __init__(self, labeler):&#10;        self.labeler = labeler&#10;        self.labeler.bbox_rects = []&#10;        self.labeler.bbox_texts = []  # Track class text items&#10;&#10;    def draw_all_bboxes(self):&#10;        for rect in self.labeler.bbox_rects:&#10;            self.labeler.canvas.delete(rect)&#10;        for text in self.labeler.bbox_texts:&#10;            self.labeler.canvas.delete(text)&#10;        self.labeler.bbox_rects.clear()&#10;        self.labeler.bbox_texts.clear()&#10;        if not self.labeler.current_image:&#10;            return&#10;        img_w, img_h = self.labeler.current_image.size&#10;        off_x = (self.labeler.canvas_width - img_w) // 2&#10;        off_y = (self.labeler.canvas_height - img_h) // 2&#10;        colors = ['red', 'blue', 'green', 'yellow', 'purple', 'orange']&#10;        for cid, xc, yc, w, h in self.labeler.bboxes:&#10;            x1, y1 = off_x + (xc - w / 2) * img_w, off_y + (yc - h / 2) * img_h&#10;            x2, y2 = off_x + (xc + w / 2) * img_w, off_y + (yc + h / 2) * img_h&#10;            color = colors[int(cid) % len(colors)]&#10;            rect = self.labeler.canvas.create_rectangle(x1, y1, x2, y2, outline=color, width=2)&#10;            self.labeler.bbox_rects.append(rect)&#10;            if int(cid) &lt; len(self.labeler.classes):&#10;                text = self.labeler.canvas.create_text(x1, y1 - 10, text=self.labeler.classes[int(cid)], fill=color, anchor=tk.W)&#10;                self.labeler.bbox_texts.append(text)&#10;&#10;    def start_bbox(self, event):&#10;        if self.labeler.mode != 'labeling' or not self.labeler.current_image:&#10;            return&#10;        self.labeler.start_x, self.labeler.start_y = event.x, event.y&#10;        if self.labeler.current_bbox:&#10;            self.labeler.canvas.delete(self.labeler.current_bbox)&#10;        self.labeler.current_bbox = None&#10;&#10;    def draw_bbox(self, event):&#10;        if self.labeler.mode != 'labeling' or self.labeler.start_x is None:&#10;            return&#10;        if self.labeler.current_bbox:&#10;            self.labeler.canvas.delete(self.labeler.current_bbox)&#10;        self.labeler.current_bbox = self.labeler.canvas.create_rectangle(&#10;            self.labeler.start_x, self.labeler.start_y, event.x, event.y, outline='red', width=2, dash=(5, 5))&#10;&#10;    def end_bbox(self, event):&#10;        if self.labeler.mode != 'labeling' or self.labeler.start_x is None:&#10;            return&#10;        if abs(event.x - self.labeler.start_x) &lt; 5 or abs(event.y - self.labeler.start_y) &lt; 5:&#10;            if self.labeler.current_bbox:&#10;                self.labeler.canvas.delete(self.labeler.current_bbox)&#10;            self.labeler.start_x = self.labeler.current_bbox = None&#10;            return&#10;        img_w, img_h = self.labeler.current_image.size&#10;        off_x, off_y = (self.labeler.canvas_width - img_w) // 2, (self.labeler.canvas_height - img_h) // 2&#10;        x1, y1 = max(0, min(self.labeler.start_x, event.x) - off_x), max(0, min(self.labeler.start_y, event.y) - off_y)&#10;        x2, y2 = min(img_w, max(self.labeler.start_x, event.x) - off_x), min(img_h, max(self.labeler.start_y, event.y) - off_y)&#10;        if x1 &gt;= x2 or y1 &gt;= y2:&#10;            return&#10;        xc, yc = (x1 + x2) / 2 / img_w, (y1 + y2) / 2 / img_h&#10;        w, h = (x2 - x1) / img_w, (y2 - y1) / img_h&#10;        self.labeler.bboxes.append((self.labeler.current_class, xc, yc, w, h))&#10;        if self.labeler.current_bbox:&#10;            self.labeler.canvas.delete(self.labeler.current_bbox)&#10;        self.labeler.start_x = self.labeler.current_bbox = None&#10;        self.draw_all_bboxes()&#10;        self.labeler.update_label_list()&#10;&#10;    def save_labels_to_txt(self):&#10;        # Save current bboxes to the corresponding txt file&#10;        if not hasattr(self.labeler, 'image_path') or not self.labeler.image_path:&#10;            return&#10;        label_path = self.labeler.image_path.rsplit('.', 1)[0] + '.txt'&#10;        with open(label_path, 'w') as f:&#10;            for bbox in self.labeler.bboxes:&#10;                f.write(' '.join(map(str, bbox)) + '\n')&#10;&#10;    def delete_bbox(self, event):&#10;        if self.labeler.mode != 'labeling' or not self.labeler.bboxes:&#10;            return&#10;        if not self.labeler.current_image:&#10;            return&#10;        img_w, img_h = self.labeler.current_image.size&#10;        off_x, off_y = (self.labeler.canvas_width - img_w) // 2, (self.labeler.canvas_height - img_h) // 2&#10;        click_x, click_y = event.x - off_x, event.y - off_y&#10;        min_dist = float('inf')&#10;        del_index = None&#10;        for i, (cid, xc, yc, w, h) in enumerate(self.labeler.bboxes):&#10;            center_x = xc * img_w&#10;            center_y = yc * img_h&#10;            dist = (center_x - click_x) ** 2 + (center_y - click_y) ** 2&#10;            if dist &lt; min_dist:&#10;                min_dist = dist&#10;                del_index = i&#10;        if del_index is not None:&#10;            del self.labeler.bboxes[del_index]&#10;            self.draw_all_bboxes()&#10;            self.labeler.update_label_list()&#10;            self.save_labels_to_txt()&#10;&#10;    def delete_selected_label(self, event):&#10;        if self.labeler.mode != 'labeling' or not self.labeler.label_listbox.curselection():&#10;            return&#10;        sel = self.labeler.label_listbox.curselection()&#10;        if sel:&#10;            idx = sel[0]&#10;            if 0 &lt;= idx &lt; len(self.labeler.bboxes):&#10;                del self.labeler.bboxes[idx]&#10;                self.draw_all_bboxes()&#10;                self.labeler.update_label_list()&#10;                self.save_labels_to_txt()&#10;" />
              <option name="updatedContent" value="import tkinter as tk&#10;&#10;class LabelingUtils:&#10;    def __init__(self, labeler):&#10;        self.labeler = labeler&#10;        self.labeler.bbox_rects = []&#10;        self.labeler.bbox_texts = []  # Track class text items&#10;&#10;    def draw_all_bboxes(self):&#10;        for rect in self.labeler.bbox_rects:&#10;            self.labeler.canvas.delete(rect)&#10;        for text in self.labeler.bbox_texts:&#10;            self.labeler.canvas.delete(text)&#10;        self.labeler.bbox_rects.clear()&#10;        self.labeler.bbox_texts.clear()&#10;        if not self.labeler.current_image:&#10;            return&#10;        img_w, img_h = self.labeler.current_image.size&#10;        off_x = (self.labeler.canvas_width - img_w) // 2&#10;        off_y = (self.labeler.canvas_height - img_h) // 2&#10;        colors = ['red', 'blue', 'green', 'yellow', 'purple', 'orange']&#10;        for cid, xc, yc, w, h in self.labeler.bboxes:&#10;            x1, y1 = off_x + (xc - w / 2) * img_w, off_y + (yc - h / 2) * img_h&#10;            x2, y2 = off_x + (xc + w / 2) * img_w, off_y + (yc + h / 2) * img_h&#10;            color = colors[int(cid) % len(colors)]&#10;            rect = self.labeler.canvas.create_rectangle(x1, y1, x2, y2, outline=color, width=2)&#10;            self.labeler.bbox_rects.append(rect)&#10;            if int(cid) &lt; len(self.labeler.classes):&#10;                text = self.labeler.canvas.create_text(x1, y1 - 10, text=self.labeler.classes[int(cid)], fill=color, anchor=tk.W)&#10;                self.labeler.bbox_texts.append(text)&#10;&#10;    def start_bbox(self, event):&#10;        if self.labeler.mode != 'labeling' or not self.labeler.current_image:&#10;            return&#10;        self.labeler.start_x, self.labeler.start_y = event.x, event.y&#10;        if self.labeler.current_bbox:&#10;            self.labeler.canvas.delete(self.labeler.current_bbox)&#10;        self.labeler.current_bbox = None&#10;&#10;    def draw_bbox(self, event):&#10;        if self.labeler.mode != 'labeling' or self.labeler.start_x is None:&#10;            return&#10;        if self.labeler.current_bbox:&#10;            self.labeler.canvas.delete(self.labeler.current_bbox)&#10;        self.labeler.current_bbox = self.labeler.canvas.create_rectangle(&#10;            self.labeler.start_x, self.labeler.start_y, event.x, event.y, outline='red', width=2, dash=(5, 5))&#10;&#10;    def end_bbox(self, event):&#10;        if self.labeler.mode != 'labeling' or self.labeler.start_x is None:&#10;            return&#10;        if abs(event.x - self.labeler.start_x) &lt; 5 or abs(event.y - self.labeler.start_y) &lt; 5:&#10;            if self.labeler.current_bbox:&#10;                self.labeler.canvas.delete(self.labeler.current_bbox)&#10;            self.labeler.start_x = self.labeler.current_bbox = None&#10;            return&#10;        img_w, img_h = self.labeler.current_image.size&#10;        off_x, off_y = (self.labeler.canvas_width - img_w) // 2, (self.labeler.canvas_height - img_h) // 2&#10;        x1, y1 = max(0, min(self.labeler.start_x, event.x) - off_x), max(0, min(self.labeler.start_y, event.y) - off_y)&#10;        x2, y2 = min(img_w, max(self.labeler.start_x, event.x) - off_x), min(img_h, max(self.labeler.start_y, event.y) - off_y)&#10;        if x1 &gt;= x2 or y1 &gt;= y2:&#10;            return&#10;        xc, yc = (x1 + x2) / 2 / img_w, (y1 + y2) / 2 / img_h&#10;        w, h = (x2 - x1) / img_w, (y2 - y1) / img_h&#10;        self.labeler.bboxes.append((self.labeler.current_class, xc, yc, w, h))&#10;        if self.labeler.current_bbox:&#10;            self.labeler.canvas.delete(self.labeler.current_bbox)&#10;        self.labeler.start_x = self.labeler.current_bbox = None&#10;        self.draw_all_bboxes()&#10;        self.labeler.update_label_list()&#10;&#10;    def save_labels_to_txt(self):&#10;        # Save current bboxes to the corresponding txt file&#10;        if not hasattr(self.labeler, 'image_path') or not self.labeler.image_path:&#10;            return&#10;        label_path = self.labeler.image_path.rsplit('.', 1)[0] + '.txt'&#10;        if not self.labeler.bboxes:&#10;            import os&#10;            if os.path.exists(label_path):&#10;                os.remove(label_path)&#10;            return&#10;        with open(label_path, 'w') as f:&#10;            for bbox in self.labeler.bboxes:&#10;                f.write(' '.join(map(str, bbox)) + '\n')&#10;&#10;    def delete_bbox(self, event):&#10;        if self.labeler.mode != 'labeling' or not self.labeler.bboxes:&#10;            return&#10;        if not self.labeler.current_image:&#10;            return&#10;        img_w, img_h = self.labeler.current_image.size&#10;        off_x, off_y = (self.labeler.canvas_width - img_w) // 2, (self.labeler.canvas_height - img_h) // 2&#10;        click_x, click_y = event.x - off_x, event.y - off_y&#10;        min_dist = float('inf')&#10;        del_index = None&#10;        for i, (cid, xc, yc, w, h) in enumerate(self.labeler.bboxes):&#10;            center_x = xc * img_w&#10;            center_y = yc * img_h&#10;            dist = (center_x - click_x) ** 2 + (center_y - click_y) ** 2&#10;            if dist &lt; min_dist:&#10;                min_dist = dist&#10;                del_index = i&#10;        if del_index is not None:&#10;            del self.labeler.bboxes[del_index]&#10;            self.draw_all_bboxes()&#10;            self.labeler.update_label_list()&#10;            self.save_labels_to_txt()&#10;&#10;    def delete_selected_label(self, event):&#10;        if self.labeler.mode != 'labeling' or not self.labeler.label_listbox.curselection():&#10;            return&#10;        sel = self.labeler.label_listbox.curselection()&#10;        if sel:&#10;            idx = sel[0]&#10;            if 0 &lt;= idx &lt; len(self.labeler.bboxes):&#10;                del self.labeler.bboxes[idx]&#10;                self.draw_all_bboxes()&#10;                self.labeler.update_label_list()&#10;                self.save_labels_to_txt()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/labelling.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/labelling.py" />
              <option name="originalContent" value="import tkinter as tk&#10;from tkinter import filedialog, messagebox&#10;import cv2&#10;import os&#10;from PIL import Image, ImageTk&#10;import numpy as np&#10;from rotation_utils import RotationUtils&#10;from labeling_utils import LabelingUtils&#10;&#10;class YOLOLabeler:&#10;    def __init__(self, root):&#10;        self.root = root&#10;        self.root.title(&quot;YOLO Image Labeler&quot;)&#10;        self.root.geometry(&quot;1200x800&quot;)&#10;        self.crosshair_lines = []&#10;&#10;        # 변수 초기화&#10;        self.original_image_cv2 = None&#10;        self.display_image_cv2 = None # 회전을 포함하여 화면에 표시될 이미지&#10;        self.current_image = None&#10;        self.image_path = None&#10;        self.image_list = []&#10;        self.current_index = 0&#10;        self.scale_factor = 1.0&#10;        self.canvas_width = 800&#10;        self.canvas_height = 600&#10;&#10;        # 바운딩 박스 관련&#10;        self.start_x = None&#10;        self.start_y = None&#10;        self.current_bbox = None&#10;        self.bboxes = []&#10;        self.bbox_rects = []&#10;&#10;        # 클래스 정보&#10;        self.classes = []&#10;        self.current_class = 0&#10;&#10;        # 모드 관리&#10;        self.mode = 'labeling' # 'labeling' vs 'rotation'&#10;        self.image_angle = 0&#10;        self.rotation_dirty = False # 회전 후 저장되지 않은 변경사항&#10;&#10;        # 마우스 드래그로 섬세한 회전 관련 변수 추가&#10;        self.image_angle_float = 0.0  # 실수형 누적 회전 각도 (마우스 드래그용)&#10;        self.drag_start_x = None&#10;        self.drag_start_y = None&#10;        self.start_angle = 0.0&#10;&#10;        # 자동 저장 모드 설정&#10;        self.auto_save_enabled = True&#10;&#10;        # 리사이즈 작업 핸들러&#10;        self.resize_job = None&#10;&#10;        self.setup_ui()&#10;        self.load_classes()&#10;        self.toggle_mode() # 초기 UI 상태 설정&#10;        self.thumbnail_size = 100&#10;        self.thumbnails = []&#10;        self.thumb_labels = []&#10;&#10;        self.rotation_utils = RotationUtils(self)&#10;        self.labeling_utils = LabelingUtils(self)&#10;&#10;    def setup_ui(self):&#10;        main_frame = tk.Frame(self.root)&#10;        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)&#10;&#10;        # 왼쪽 썸네일 영역&#10;        thumb_frame = tk.Frame(main_frame, width=120)&#10;        thumb_frame.pack(side=tk.LEFT, fill=tk.Y)&#10;        thumb_frame.pack_propagate(False)&#10;&#10;        # 썸네일용 캔버스 + 스크롤바 조합&#10;        self.thumb_canvas = tk.Canvas(thumb_frame, width=120)&#10;        self.thumb_scrollbar = tk.Scrollbar(thumb_frame, orient=tk.VERTICAL, command=self.thumb_canvas.yview)&#10;        self.thumb_scrollable_frame = tk.Frame(self.thumb_canvas)&#10;&#10;        self.thumb_scrollable_frame.bind(&#10;            &quot;&lt;Configure&gt;&quot;,&#10;            lambda e: self.thumb_canvas.configure(&#10;                scrollregion=self.thumb_canvas.bbox(&quot;all&quot;)&#10;            )&#10;        )&#10;&#10;        self.thumb_canvas.create_window((0, 0), window=self.thumb_scrollable_frame, anchor=&quot;nw&quot;)&#10;        self.thumb_canvas.configure(yscrollcommand=self.thumb_scrollbar.set)&#10;&#10;        self.thumb_canvas.pack(side=tk.LEFT, fill=tk.Y, expand=True)&#10;        self.thumb_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)&#10;&#10;        # 마우스 휠, 트랙패드, 방향키 스크롤 이벤트 바인딩 (윈도우/맥/리눅스 호환)&#10;        def _on_mousewheel(event):&#10;            if os.name == 'nt':&#10;                self.thumb_canvas.yview_scroll(-1 * int(event.delta / 120), &quot;units&quot;)&#10;            else:&#10;                self.thumb_canvas.yview_scroll(-1 * int(event.delta), &quot;units&quot;)&#10;        self.thumb_canvas.bind_all(&quot;&lt;MouseWheel&gt;&quot;, _on_mousewheel)&#10;        self.thumb_canvas.bind_all(&quot;&lt;Button-4&gt;&quot;, lambda e: self.thumb_canvas.yview_scroll(-1, &quot;units&quot;))&#10;        self.thumb_canvas.bind_all(&quot;&lt;Button-5&gt;&quot;, lambda e: self.thumb_canvas.yview_scroll(1, &quot;units&quot;))&#10;        # 방향키(Up/Down)로 썸네일 스크롤&#10;        self.thumb_canvas.bind_all(&quot;&lt;Up&gt;&quot;, lambda e: self.thumb_canvas.yview_scroll(-3, &quot;units&quot;))&#10;        self.thumb_canvas.bind_all(&quot;&lt;Down&gt;&quot;, lambda e: self.thumb_canvas.yview_scroll(3, &quot;units&quot;))&#10;        # 트랙패드 두 손가락 스와이프(Shift+MouseWheel)도 지원&#10;        self.thumb_canvas.bind_all(&quot;&lt;Shift-MouseWheel&gt;&quot;, _on_mousewheel)&#10;&#10;        left_frame = tk.Frame(main_frame)&#10;        left_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)&#10;&#10;        self.canvas = tk.Canvas(left_frame, bg='white')&#10;        self.canvas.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)&#10;&#10;        self.canvas.bind(&quot;&lt;Configure&gt;&quot;, self.on_canvas_resize)&#10;        self.canvas.bind(&quot;&lt;ButtonPress-1&gt;&quot;, self.on_canvas_button_press)&#10;        self.canvas.bind(&quot;&lt;B1-Motion&gt;&quot;, self.on_canvas_mouse_drag)&#10;        self.canvas.bind(&quot;&lt;ButtonRelease-1&gt;&quot;, self.on_canvas_button_release)&#10;        self.canvas.bind(&quot;&lt;Button-3&gt;&quot;, lambda event: self.labeling_utils.delete_bbox(event))&#10;        self.canvas.bind(&quot;&lt;Button-2&gt;&quot;, lambda event: self.labeling_utils.delete_bbox(event))&#10;&#10;        nav_frame = tk.Frame(left_frame)&#10;        nav_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=5)&#10;&#10;        tk.Button(nav_frame, text=&quot;이전&quot;, command=self.prev_image).pack(side=tk.LEFT, padx=5)&#10;        tk.Button(nav_frame, text=&quot;다음&quot;, command=self.next_image).pack(side=tk.LEFT, padx=5)&#10;&#10;        self.image_info_label = tk.Label(nav_frame, text=&quot;이미지 없음&quot;)&#10;        self.image_info_label.pack(side=tk.LEFT, padx=20)&#10;&#10;        right_frame = tk.Frame(main_frame, width=300)&#10;        right_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=10)&#10;        right_frame.pack_propagate(False)&#10;&#10;        file_frame = tk.LabelFrame(right_frame, text=&quot;파일 관리&quot;)&#10;        file_frame.pack(fill=tk.X, pady=5)&#10;        tk.Button(file_frame, text=&quot;이미지 폴더 선택&quot;, command=self.load_images).pack(fill=tk.X, padx=5, pady=2)&#10;        tk.Button(file_frame, text=&quot;이미지 파일 선택&quot;, command=self.load_single_image).pack(fill=tk.X, padx=5, pady=2)&#10;        tk.Button(file_frame, text=&quot;클래스 설정&quot;, command=self.setup_classes).pack(fill=tk.X, padx=5, pady=2)&#10;&#10;        mode_frame = tk.LabelFrame(right_frame, text=&quot;모드 설정&quot;)&#10;        mode_frame.pack(fill=tk.X, pady=5)&#10;        self.mode_var = tk.StringVar(value=self.mode)&#10;        tk.Radiobutton(mode_frame, text=&quot;라벨링&quot;, variable=self.mode_var, value=&quot;labeling&quot;, command=self.toggle_mode).pack(side=tk.LEFT, padx=10)&#10;        tk.Radiobutton(mode_frame, text=&quot;회전&quot;, variable=self.mode_var, value=&quot;rotation&quot;, command=self.toggle_mode).pack(side=tk.LEFT, padx=10)&#10;&#10;        rotation_frame = tk.LabelFrame(right_frame, text=&quot;이미지 회전&quot;)&#10;        rotation_frame.pack(fill=tk.X, pady=5)&#10;        self.rotate_left_btn = tk.Button(rotation_frame, text=&quot;왼쪽 회전 (90도)&quot;, command=self.rotate_image_left)&#10;        self.rotate_left_btn.pack(fill=tk.X, padx=5, pady=2)&#10;        self.rotate_right_btn = tk.Button(rotation_frame, text=&quot;오른쪽 회전 (90도)&quot;, command=self.rotate_image_right)&#10;        self.rotate_right_btn.pack(fill=tk.X, padx=5, pady=2)&#10;&#10;        class_frame = tk.LabelFrame(right_frame, text=&quot;클래스 선택&quot;)&#10;        class_frame.pack(fill=tk.X, pady=5)&#10;        self.calculate_class_frame_height()&#10;        canvas_frame = tk.Canvas(class_frame, height=self.class_frame_height)&#10;        scrollbar_class = tk.Scrollbar(class_frame, orient=&quot;vertical&quot;, command=canvas_frame.yview)&#10;        self.scrollable_frame = tk.Frame(canvas_frame)&#10;        self.scrollable_frame.bind(&quot;&lt;Configure&gt;&quot;, lambda e: canvas_frame.configure(scrollregion=canvas_frame.bbox(&quot;all&quot;)))&#10;        canvas_frame.create_window((0, 0), window=self.scrollable_frame, anchor=&quot;nw&quot;)&#10;        canvas_frame.configure(yscrollcommand=scrollbar_class.set)&#10;        canvas_frame.pack(side=&quot;left&quot;, fill=&quot;both&quot;, expand=True, padx=(5, 0), pady=5)&#10;        scrollbar_class.pack(side=&quot;right&quot;, fill=&quot;y&quot;, pady=5)&#10;        self.canvas_frame = canvas_frame&#10;        self.class_var = tk.IntVar(value=0)&#10;        self.class_radiobuttons = []&#10;        self.update_class_radiobuttons()&#10;&#10;        label_frame = tk.LabelFrame(right_frame, text=&quot;현재 라벨&quot;)&#10;        label_frame.pack(fill=tk.BOTH, expand=True, pady=5)&#10;        list_frame = tk.Frame(label_frame)&#10;        list_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)&#10;        self.label_listbox = tk.Listbox(list_frame)&#10;        scrollbar = tk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.label_listbox.yview)&#10;        self.label_listbox.config(yscrollcommand=scrollbar.set)&#10;        self.label_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)&#10;        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)&#10;        self.label_listbox.bind(&quot;&lt;Double-Button-1&gt;&quot;, self.delete_selected_label)&#10;&#10;        save_frame = tk.LabelFrame(right_frame, text=&quot;저장&quot;)&#10;        save_frame.pack(fill=tk.X, pady=5)&#10;        self.auto_save_var = tk.BooleanVar(value=self.auto_save_enabled)&#10;        auto_save_checkbox = tk.Checkbutton(save_frame, text=&quot;자동 저장 모드&quot;, variable=self.auto_save_var, command=self.toggle_auto_save)&#10;        auto_save_checkbox.pack(fill=tk.X, padx=5, pady=2)&#10;        tk.Button(save_frame, text=&quot;저장&quot;, command=self.save_changes).pack(fill=tk.X, padx=5, pady=2)&#10;&#10;        self.thumbnails = []  # PIL 이미지들&#10;        self.thumb_labels = []  # Label 위젯들&#10;&#10;        self.root.bind('&lt;Left&gt;', lambda event: self.prev_image())&#10;        self.root.bind('&lt;Right&gt;', lambda event: self.next_image())&#10;        # 라벨링 모드 단축키&#10;        for key in ['w', 'W']:&#10;            self.root.bind(f'&lt;{key}&gt;', lambda event: self.set_mode_labeling())&#10;        # 회전 모드 단축키&#10;        for key in ['r', 'R']:&#10;            self.root.bind(f'&lt;{key}&gt;', lambda event: self.set_mode_rotation())&#10;&#10;    def on_canvas_resize(self, event):&#10;        if self.resize_job: self.root.after_cancel(self.resize_job)&#10;        self.resize_job = self.root.after(200, self.perform_resize)&#10;&#10;    def perform_resize(self):&#10;        if self.display_image_cv2 is None: return&#10;        h, w = self.display_image_cv2.shape[:2]&#10;        self.canvas_width, self.canvas_height = self.canvas.winfo_width(), self.canvas.winfo_height()&#10;        if self.canvas_width &lt; 2 or self.canvas_height &lt; 2: return&#10;        self.scale_factor = min(self.canvas_width / w, self.canvas_height / h)&#10;        new_w, new_h = int(w * self.scale_factor), int(h * self.scale_factor)&#10;        if new_w &lt; 1 or new_h &lt; 1: return&#10;        img_resized = cv2.resize(self.display_image_cv2, (new_w, new_h))&#10;        self.current_image = Image.fromarray(img_resized)&#10;        self.photo = ImageTk.PhotoImage(self.current_image)&#10;        self.canvas.delete(&quot;all&quot;)&#10;        self.canvas.create_image(self.canvas_width // 2, self.canvas_height // 2, image=self.photo)&#10;        self.draw_all_bboxes()&#10;        if self.mode == 'rotation':&#10;            self.draw_crosshair_lines()&#10;&#10;    def load_classes(self):&#10;        if os.path.exists(&quot;classes.txt&quot;):&#10;            with open(&quot;classes.txt&quot;, 'r', encoding='utf-8') as f:&#10;                self.classes = [line.strip() for line in f.readlines() if line.strip()]&#10;        else:&#10;            self.classes = [&quot;person&quot;, &quot;car&quot;, &quot;bike&quot;, &quot;dog&quot;, &quot;cat&quot;]&#10;        self.update_class_radiobuttons()&#10;&#10;    def setup_classes(self):&#10;        class_window = tk.Toplevel(self.root)&#10;        class_window.title(&quot;클래스 설정&quot;)&#10;        text_widget = tk.Text(class_window, height=15)&#10;        text_widget.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)&#10;        text_widget.insert(tk.END, '\n'.join(self.classes))&#10;        def save_classes():&#10;            self.classes = [cls.strip() for cls in text_widget.get(1.0, tk.END).strip().split('\n') if cls.strip()]&#10;            with open(&quot;classes.txt&quot;, 'w', encoding='utf-8') as f: f.write('\n'.join(self.classes))&#10;            self.update_class_radiobuttons()&#10;            class_window.destroy()&#10;        tk.Button(class_window, text=&quot;저장&quot;, command=save_classes).pack(pady=5)&#10;&#10;    def update_class_radiobuttons(self):&#10;        for rb in self.class_radiobuttons: rb.destroy()&#10;        self.class_radiobuttons.clear()&#10;        self.calculate_class_frame_height()&#10;        if hasattr(self, 'canvas_frame'): self.canvas_frame.config(height=self.class_frame_height)&#10;        self.class_var.set(0)&#10;        for i, class_name in enumerate(self.classes):&#10;            rb = tk.Radiobutton(self.scrollable_frame, text=class_name, variable=self.class_var, value=i, indicatoron=0, anchor=&quot;w&quot;, command=self.on_class_selected)&#10;            rb.pack(fill=tk.X, padx=5, pady=2)&#10;            self.class_radiobuttons.append(rb)&#10;        if self.classes: self.current_class = 0&#10;        self.toggle_mode()&#10;&#10;    def on_class_selected(self, event=None): self.current_class = self.class_var.get()&#10;&#10;    def load_single_image(self):&#10;        if not self.check_unsaved_rotation(): return&#10;        file_path = filedialog.askopenfilename(filetypes=(('Image Files', '*.jpg *.jpeg *.png *.bmp'), ('All Files', '*.*')))&#10;        if file_path:&#10;            self.image_list = [file_path]&#10;            self.current_index = 0&#10;            self.load_current_image()&#10;&#10;    def load_images(self):&#10;        if not self.check_unsaved_rotation(): return&#10;        folder_path = filedialog.askdirectory()&#10;        if folder_path:&#10;            ext = ('.jpg', '.jpeg', '.png', '.bmp')&#10;            self.image_list = sorted([os.path.join(folder_path, f) for f in os.listdir(folder_path) if f.lower().endswith(ext)])&#10;            if self.image_list:&#10;                self.current_index = 0&#10;                self.load_current_image()&#10;                self.load_thumbnails()  # 추가: 썸네일 생성&#10;            else:&#10;                messagebox.showwarning(&quot;경고&quot;, &quot;이미지 파일을 찾을 수 없습니다.&quot;)&#10;&#10;    def load_current_image(self):&#10;        if not self.image_list: return&#10;        self.image_path = self.image_list[self.current_index]&#10;        img = cv2.imread(self.image_path)&#10;        if img is None:&#10;            messagebox.showerror(&quot;오류&quot;, f&quot;이미지를 읽을 수 없습니다: {self.image_path}&quot;)&#10;            return&#10;        self.original_image_cv2 = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)&#10;        self.display_image_cv2 = self.original_image_cv2.copy()&#10;        self.image_angle = 0&#10;        self.image_angle_float = 0.0&#10;        self.rotation_dirty = False&#10;        self.bboxes, self.bbox_rects = [], []&#10;        label_path = self.image_path.rsplit('.', 1)[0] + '.txt'&#10;        if os.path.exists(label_path):&#10;            with open(label_path, 'r') as f:&#10;                for line in f:&#10;                    parts = line.strip().split()&#10;                    if len(parts) == 5:&#10;                        self.bboxes.append(tuple(map(float, parts)))&#10;        self.perform_resize()&#10;        self.update_image_info()&#10;        self.update_label_list()&#10;&#10;    def load_thumbnails(self):&#10;        # 기존 썸네일 삭제&#10;        for lbl in self.thumb_labels:&#10;            lbl.destroy()&#10;        self.thumb_labels.clear()&#10;        self.thumbnails.clear()&#10;&#10;        for i, img_path in enumerate(self.image_list):&#10;            img = Image.open(img_path)&#10;            img.thumbnail((self.thumbnail_size, self.thumbnail_size))&#10;            thumb = ImageTk.PhotoImage(img)&#10;            self.thumbnails.append(thumb)  # 참조 유지 중요!&#10;&#10;            lbl = tk.Label(self.thumb_scrollable_frame, image=thumb, cursor=&quot;hand2&quot;, borderwidth=2, relief=&quot;groove&quot;)&#10;            lbl.pack(padx=5, pady=5)&#10;&#10;            def click_handler(event, idx=i):&#10;                if self.auto_save_enabled:&#10;                    if self.rotation_dirty:&#10;                        self.save_rotation()&#10;                    self.save_current_labels()&#10;                if not self.check_unsaved_rotation():&#10;                    return&#10;                self.current_index = idx&#10;                self.load_current_image()&#10;&#10;            lbl.bind(&quot;&lt;Button-1&gt;&quot;, click_handler)&#10;            self.thumb_labels.append(lbl)&#10;&#10;    def apply_rotation_and_redraw(self):&#10;        self.rotation_utils.apply_rotation_and_redraw()&#10;&#10;    def rotate_image_left(self):&#10;        self.rotation_utils.rotate_image_left()&#10;&#10;    def rotate_image_right(self):&#10;        self.rotation_utils.rotate_image_right()&#10;&#10;    def apply_smooth_rotation(self):&#10;        self.rotation_utils.apply_smooth_rotation()&#10;&#10;    def draw_all_bboxes(self):&#10;        self.labeling_utils.draw_all_bboxes()&#10;&#10;    def start_bbox(self, event):&#10;        self.labeling_utils.start_bbox(event)&#10;&#10;    def draw_bbox(self, event):&#10;        self.labeling_utils.draw_bbox(event)&#10;&#10;    def end_bbox(self, event):&#10;        self.labeling_utils.end_bbox(event)&#10;&#10;    def delete_bbox(self, event):&#10;        self.labeling_utils.delete_bbox(event)&#10;&#10;    def delete_selected_label(self, event):&#10;        self.labeling_utils.delete_selected_label(event)&#10;&#10;    def update_label_list(self):&#10;        self.label_listbox.delete(0, tk.END)&#10;        for i, (cid, xc, yc, w, h) in enumerate(self.bboxes):&#10;            c_name = self.classes[int(cid)] if int(cid) &lt; len(self.classes) else f&quot;Class{int(cid)}&quot;&#10;            self.label_listbox.insert(tk.END, f&quot;{i+1}. {c_name} ({w:.3f}x{h:.3f})&quot;)&#10;&#10;    def update_image_info(self):&#10;        text = f&quot;{self.current_index + 1}/{len(self.image_list)} - {os.path.basename(self.image_path)}&quot; if self.image_list else &quot;이미지 없음&quot;&#10;        self.image_info_label.config(text=text)&#10;&#10;    def prev_image(self):&#10;        if not self.check_unsaved_rotation(): return&#10;        if self.image_list and self.current_index &gt; 0:&#10;            if self.auto_save_enabled:&#10;                if self.rotation_dirty:&#10;                    self.save_rotation()&#10;                self.save_current_labels()&#10;            self.current_index -= 1&#10;            self.load_current_image()&#10;&#10;    def next_image(self):&#10;        if self.image_list and self.current_index &lt; len(self.image_list) - 1:&#10;            if self.auto_save_enabled:&#10;                if self.rotation_dirty:&#10;                    self.save_rotation()&#10;                # Save labels and remove txt file if no labels&#10;                if not self.bboxes:&#10;                    label_path = self.image_path.rsplit('.', 1)[0] + '.txt'&#10;                    if os.path.exists(label_path):&#10;                        os.remove(label_path)&#10;                else:&#10;                    self.save_current_labels()&#10;            self.current_index += 1&#10;            self.load_current_image()&#10;&#10;    def save_current_labels(self):&#10;        if not self.image_path or not self.bboxes:&#10;            return&#10;        label_path = self.image_path.rsplit('.', 1)[0] + '.txt'&#10;        with open(label_path, 'w') as f:&#10;            for cid, xc, yc, w, h in self.bboxes:&#10;                f.write(f&quot;{int(cid)} {xc:.6f} {yc:.6f} {w:.6f} {h:.6f}\n&quot;)&#10;&#10;    def save_changes(self):&#10;        if self.mode == 'rotation':&#10;            if self.rotation_dirty:&#10;                self.save_rotation()&#10;            else:&#10;                messagebox.showinfo(&quot;정보&quot;, &quot;회���된 내용이 없습니다.&quot;)&#10;        elif self.mode == 'labeling':&#10;            if not self.image_path:&#10;                messagebox.showwarning(&quot;경고&quot;, &quot;저장할 이미지가 없습니다.&quot;)&#10;                return&#10;            self.save_current_labels()&#10;&#10;    def calculate_class_frame_height(self):&#10;        self.class_frame_height = max(80, min(300, len(self.classes) * 30 + 20))&#10;&#10;    def toggle_auto_save(self): self.auto_save_enabled = self.auto_save_var.get()&#10;&#10;    def toggle_mode(self):&#10;        self.mode = self.mode_var.get()&#10;        is_rotation_mode = self.mode == 'rotation'&#10;&#10;        self.rotate_left_btn.config(state=tk.NORMAL if is_rotation_mode else tk.DISABLED)&#10;        self.rotate_right_btn.config(state=tk.NORMAL if is_rotation_mode else tk.DISABLED)&#10;&#10;        for rb in self.class_radiobuttons:&#10;            rb.config(state=tk.DISABLED if is_rotation_mode else tk.NORMAL)&#10;&#10;        self.canvas.config(cursor=&quot;arrow&quot; if is_rotation_mode else &quot;crosshair&quot;)&#10;&#10;        if is_rotation_mode:&#10;            self.draw_crosshair_lines()&#10;        else:&#10;            for line_id in self.crosshair_lines:&#10;                self.canvas.delete(line_id)&#10;            self.crosshair_lines.clear()&#10;&#10;&#10;    def on_canvas_button_press(self, event):&#10;        if self.mode == 'rotation':&#10;            self.drag_start_x = event.x&#10;            self.drag_start_y = event.y&#10;            self.start_angle = self.image_angle_float&#10;        elif self.mode == 'labeling':&#10;            self.start_bbox(event)&#10;&#10;    def on_canvas_mouse_drag(self, event):&#10;        if self.mode == 'rotation' and self.drag_start_x is not None:&#10;            delta_x = event.x - self.drag_start_x&#10;            sensitivity = 0.5  # 1픽셀당 0.5도 회전, 필요시 조절 가능&#10;            delta_angle = delta_x * sensitivity&#10;            new_angle = (self.start_angle + delta_angle) % 360&#10;            self.image_angle_float = new_angle&#10;            self.apply_smooth_rotation()&#10;        elif self.mode == 'labeling':&#10;            self.draw_bbox(event)&#10;&#10;    def on_canvas_button_release(self, event):&#10;        if self.mode == 'rotation' and self.drag_start_x is not None:&#10;            self.image_angle_float = self.image_angle_float % 360&#10;            self.image_angle = int(round(self.image_angle_float))&#10;            self.rotation_dirty = True&#10;            self.drag_start_x = None&#10;            self.drag_start_y = None&#10;            self.start_angle = 0.0&#10;        elif self.mode == 'labeling':&#10;            self.end_bbox(event)&#10;&#10;&#10;    def save_rotation(self):&#10;        img_to_save = cv2.cvtColor(self.display_image_cv2, cv2.COLOR_RGB2BGR)&#10;        try:&#10;            cv2.imwrite(self.image_path, img_to_save)&#10;            self.original_image_cv2 = self.display_image_cv2.copy()&#10;            self.rotation_dirty = False&#10;            self.image_angle = 0&#10;            self.image_angle_float = 0.0&#10;        except Exception as e:&#10;            messagebox.showerror(&quot;오류&quot;, f&quot;이미지 저장에 실패했습니다: {e}&quot;)&#10;&#10;    def check_unsaved_rotation(self):&#10;        if self.rotation_dirty:&#10;            response = messagebox.askyesnocancel(&quot;저장 확인&quot;, &quot;회전된 이미지가 저장되지 않았습니다. 저장하시겠습니까?&quot;)&#10;            if response is True:&#10;                self.save_rotation()&#10;                return True&#10;            elif response is False:&#10;                return True&#10;            else:&#10;                return False&#10;        return True&#10;&#10;    def draw_crosshair_lines(self):&#10;        if self.display_image_cv2 is None:&#10;            return&#10;        # 기존 보조선 삭제&#10;        for line_id in self.crosshair_lines:&#10;            self.canvas.delete(line_id)&#10;        self.crosshair_lines = []&#10;&#10;        w, h = self.canvas.winfo_width(), self.canvas.winfo_height()&#10;        center_x, center_y = w // 2, h // 2&#10;&#10;        # 가로/세로 파선 보조선 추가&#10;        h_line = self.canvas.create_line(0, center_y, w, center_y, fill='blue', dash=(4, 4))&#10;        v_line = self.canvas.create_line(center_x, 0, center_x, h, fill='blue', dash=(4, 4))&#10;&#10;        self.crosshair_lines.extend([h_line, v_line])&#10;&#10;    def set_mode_labeling(self):&#10;        self.mode_var.set('labeling')&#10;        self.toggle_mode()&#10;&#10;    def set_mode_rotation(self):&#10;        self.mode_var.set('rotation')&#10;        self.toggle_mode()&#10;&#10;def main():&#10;    root = tk.Tk()&#10;    app = YOLOLabeler(root)&#10;    root.mainloop()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="import tkinter as tk&#10;from tkinter import filedialog, messagebox&#10;import cv2&#10;import os&#10;from PIL import Image, ImageTk&#10;import numpy as np&#10;from rotation_utils import RotationUtils&#10;from labeling_utils import LabelingUtils&#10;&#10;class YOLOLabeler:&#10;    def __init__(self, root):&#10;        self.root = root&#10;        self.root.title(&quot;YOLO Image Labeler&quot;)&#10;        self.root.geometry(&quot;1200x800&quot;)&#10;        self.crosshair_lines = []&#10;&#10;        # 변수 초기화&#10;        self.original_image_cv2 = None&#10;        self.display_image_cv2 = None # 회전을 포함하여 화면에 표시될 이미지&#10;        self.current_image = None&#10;        self.image_path = None&#10;        self.image_list = []&#10;        self.current_index = 0&#10;        self.scale_factor = 1.0&#10;        self.canvas_width = 800&#10;        self.canvas_height = 600&#10;&#10;        # 바운딩 박스 관련&#10;        self.start_x = None&#10;        self.start_y = None&#10;        self.current_bbox = None&#10;        self.bboxes = []&#10;        self.bbox_rects = []&#10;&#10;        # 클래스 정보&#10;        self.classes = []&#10;        self.current_class = 0&#10;&#10;        # 모드 관리&#10;        self.mode = 'labeling' # 'labeling' vs 'rotation'&#10;        self.image_angle = 0&#10;        self.rotation_dirty = False # 회전 후 저장되지 않은 변경사항&#10;&#10;        # 마우스 드래그로 섬세한 회전 관련 변수 추가&#10;        self.image_angle_float = 0.0  # 실수형 누적 회전 각도 (마우스 드래그용)&#10;        self.drag_start_x = None&#10;        self.drag_start_y = None&#10;        self.start_angle = 0.0&#10;&#10;        # 자동 저장 모드 설정&#10;        self.auto_save_enabled = True&#10;&#10;        # 리사이즈 작업 핸들러&#10;        self.resize_job = None&#10;&#10;        self.setup_ui()&#10;        self.load_classes()&#10;        self.toggle_mode() # 초기 UI 상태 설정&#10;        self.thumbnail_size = 100&#10;        self.thumbnails = []&#10;        self.thumb_labels = []&#10;&#10;        self.rotation_utils = RotationUtils(self)&#10;        self.labeling_utils = LabelingUtils(self)&#10;&#10;    def setup_ui(self):&#10;        main_frame = tk.Frame(self.root)&#10;        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)&#10;&#10;        # 왼쪽 썸네일 영역&#10;        thumb_frame = tk.Frame(main_frame, width=120)&#10;        thumb_frame.pack(side=tk.LEFT, fill=tk.Y)&#10;        thumb_frame.pack_propagate(False)&#10;&#10;        # 썸네일용 캔버스 + 스크롤바 조합&#10;        self.thumb_canvas = tk.Canvas(thumb_frame, width=120)&#10;        self.thumb_scrollbar = tk.Scrollbar(thumb_frame, orient=tk.VERTICAL, command=self.thumb_canvas.yview)&#10;        self.thumb_scrollable_frame = tk.Frame(self.thumb_canvas)&#10;&#10;        self.thumb_scrollable_frame.bind(&#10;            &quot;&lt;Configure&gt;&quot;,&#10;            lambda e: self.thumb_canvas.configure(&#10;                scrollregion=self.thumb_canvas.bbox(&quot;all&quot;)&#10;            )&#10;        )&#10;&#10;        self.thumb_canvas.create_window((0, 0), window=self.thumb_scrollable_frame, anchor=&quot;nw&quot;)&#10;        self.thumb_canvas.configure(yscrollcommand=self.thumb_scrollbar.set)&#10;&#10;        self.thumb_canvas.pack(side=tk.LEFT, fill=tk.Y, expand=True)&#10;        self.thumb_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)&#10;&#10;        # 마우스 휠, 트랙패드, 방향키 스크롤 이벤트 바인딩 (윈도우/맥/리눅스 호환)&#10;        def _on_mousewheel(event):&#10;            if os.name == 'nt':&#10;                self.thumb_canvas.yview_scroll(-1 * int(event.delta / 120), &quot;units&quot;)&#10;            else:&#10;                self.thumb_canvas.yview_scroll(-1 * int(event.delta), &quot;units&quot;)&#10;        self.thumb_canvas.bind_all(&quot;&lt;MouseWheel&gt;&quot;, _on_mousewheel)&#10;        self.thumb_canvas.bind_all(&quot;&lt;Button-4&gt;&quot;, lambda e: self.thumb_canvas.yview_scroll(-1, &quot;units&quot;))&#10;        self.thumb_canvas.bind_all(&quot;&lt;Button-5&gt;&quot;, lambda e: self.thumb_canvas.yview_scroll(1, &quot;units&quot;))&#10;        # 방향키(Up/Down)로 썸네일 스크롤&#10;        self.thumb_canvas.bind_all(&quot;&lt;Up&gt;&quot;, lambda e: self.thumb_canvas.yview_scroll(-3, &quot;units&quot;))&#10;        self.thumb_canvas.bind_all(&quot;&lt;Down&gt;&quot;, lambda e: self.thumb_canvas.yview_scroll(3, &quot;units&quot;))&#10;        # 트랙패드 두 손가락 스와이프(Shift+MouseWheel)도 지원&#10;        self.thumb_canvas.bind_all(&quot;&lt;Shift-MouseWheel&gt;&quot;, _on_mousewheel)&#10;&#10;        left_frame = tk.Frame(main_frame)&#10;        left_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)&#10;&#10;        self.canvas = tk.Canvas(left_frame, bg='white')&#10;        self.canvas.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)&#10;&#10;        self.canvas.bind(&quot;&lt;Configure&gt;&quot;, self.on_canvas_resize)&#10;        self.canvas.bind(&quot;&lt;ButtonPress-1&gt;&quot;, self.on_canvas_button_press)&#10;        self.canvas.bind(&quot;&lt;B1-Motion&gt;&quot;, self.on_canvas_mouse_drag)&#10;        self.canvas.bind(&quot;&lt;ButtonRelease-1&gt;&quot;, self.on_canvas_button_release)&#10;        self.canvas.bind(&quot;&lt;Button-3&gt;&quot;, lambda event: self.labeling_utils.delete_bbox(event))&#10;        self.canvas.bind(&quot;&lt;Button-2&gt;&quot;, lambda event: self.labeling_utils.delete_bbox(event))&#10;&#10;        nav_frame = tk.Frame(left_frame)&#10;        nav_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=5)&#10;&#10;        tk.Button(nav_frame, text=&quot;이전&quot;, command=self.prev_image).pack(side=tk.LEFT, padx=5)&#10;        tk.Button(nav_frame, text=&quot;다음&quot;, command=self.next_image).pack(side=tk.LEFT, padx=5)&#10;&#10;        self.image_info_label = tk.Label(nav_frame, text=&quot;이미지 없음&quot;)&#10;        self.image_info_label.pack(side=tk.LEFT, padx=20)&#10;&#10;        right_frame = tk.Frame(main_frame, width=300)&#10;        right_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=10)&#10;        right_frame.pack_propagate(False)&#10;&#10;        file_frame = tk.LabelFrame(right_frame, text=&quot;파일 관리&quot;)&#10;        file_frame.pack(fill=tk.X, pady=5)&#10;        tk.Button(file_frame, text=&quot;이미지 폴더 선택&quot;, command=self.load_images).pack(fill=tk.X, padx=5, pady=2)&#10;        tk.Button(file_frame, text=&quot;이미지 파일 선택&quot;, command=self.load_single_image).pack(fill=tk.X, padx=5, pady=2)&#10;        tk.Button(file_frame, text=&quot;클래스 설정&quot;, command=self.setup_classes).pack(fill=tk.X, padx=5, pady=2)&#10;&#10;        mode_frame = tk.LabelFrame(right_frame, text=&quot;모드 설정&quot;)&#10;        mode_frame.pack(fill=tk.X, pady=5)&#10;        self.mode_var = tk.StringVar(value=self.mode)&#10;        tk.Radiobutton(mode_frame, text=&quot;라벨링&quot;, variable=self.mode_var, value=&quot;labeling&quot;, command=self.toggle_mode).pack(side=tk.LEFT, padx=10)&#10;        tk.Radiobutton(mode_frame, text=&quot;회전&quot;, variable=self.mode_var, value=&quot;rotation&quot;, command=self.toggle_mode).pack(side=tk.LEFT, padx=10)&#10;&#10;        rotation_frame = tk.LabelFrame(right_frame, text=&quot;이미지 회전&quot;)&#10;        rotation_frame.pack(fill=tk.X, pady=5)&#10;        self.rotate_left_btn = tk.Button(rotation_frame, text=&quot;왼쪽 회전 (90도)&quot;, command=self.rotate_image_left)&#10;        self.rotate_left_btn.pack(fill=tk.X, padx=5, pady=2)&#10;        self.rotate_right_btn = tk.Button(rotation_frame, text=&quot;오른쪽 회전 (90도)&quot;, command=self.rotate_image_right)&#10;        self.rotate_right_btn.pack(fill=tk.X, padx=5, pady=2)&#10;&#10;        class_frame = tk.LabelFrame(right_frame, text=&quot;클래스 선택&quot;)&#10;        class_frame.pack(fill=tk.X, pady=5)&#10;        self.calculate_class_frame_height()&#10;        canvas_frame = tk.Canvas(class_frame, height=self.class_frame_height)&#10;        scrollbar_class = tk.Scrollbar(class_frame, orient=&quot;vertical&quot;, command=canvas_frame.yview)&#10;        self.scrollable_frame = tk.Frame(canvas_frame)&#10;        self.scrollable_frame.bind(&quot;&lt;Configure&gt;&quot;, lambda e: canvas_frame.configure(scrollregion=canvas_frame.bbox(&quot;all&quot;)))&#10;        canvas_frame.create_window((0, 0), window=self.scrollable_frame, anchor=&quot;nw&quot;)&#10;        canvas_frame.configure(yscrollcommand=scrollbar_class.set)&#10;        canvas_frame.pack(side=&quot;left&quot;, fill=&quot;both&quot;, expand=True, padx=(5, 0), pady=5)&#10;        scrollbar_class.pack(side=&quot;right&quot;, fill=&quot;y&quot;, pady=5)&#10;        self.canvas_frame = canvas_frame&#10;        self.class_var = tk.IntVar(value=0)&#10;        self.class_radiobuttons = []&#10;        self.update_class_radiobuttons()&#10;&#10;        label_frame = tk.LabelFrame(right_frame, text=&quot;현재 라벨&quot;)&#10;        label_frame.pack(fill=tk.BOTH, expand=True, pady=5)&#10;        list_frame = tk.Frame(label_frame)&#10;        list_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)&#10;        self.label_listbox = tk.Listbox(list_frame)&#10;        scrollbar = tk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.label_listbox.yview)&#10;        self.label_listbox.config(yscrollcommand=scrollbar.set)&#10;        self.label_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)&#10;        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)&#10;        self.label_listbox.bind(&quot;&lt;Double-Button-1&gt;&quot;, self.delete_selected_label)&#10;&#10;        save_frame = tk.LabelFrame(right_frame, text=&quot;저장&quot;)&#10;        save_frame.pack(fill=tk.X, pady=5)&#10;        self.auto_save_var = tk.BooleanVar(value=self.auto_save_enabled)&#10;        auto_save_checkbox = tk.Checkbutton(save_frame, text=&quot;자동 저장 모드&quot;, variable=self.auto_save_var, command=self.toggle_auto_save)&#10;        auto_save_checkbox.pack(fill=tk.X, padx=5, pady=2)&#10;        tk.Button(save_frame, text=&quot;저장&quot;, command=self.save_changes).pack(fill=tk.X, padx=5, pady=2)&#10;&#10;        self.thumbnails = []  # PIL 이미지들&#10;        self.thumb_labels = []  # Label 위젯들&#10;&#10;        self.root.bind('&lt;Left&gt;', lambda event: self.prev_image())&#10;        self.root.bind('&lt;Right&gt;', lambda event: self.next_image())&#10;        # 라벨링 모드 단축키&#10;        for key in ['w', 'W']:&#10;            self.root.bind(f'&lt;{key}&gt;', lambda event: self.set_mode_labeling())&#10;        # 회전 모드 단축키&#10;        for key in ['r', 'R']:&#10;            self.root.bind(f'&lt;{key}&gt;', lambda event: self.set_mode_rotation())&#10;&#10;    def on_canvas_resize(self, event):&#10;        if self.resize_job: self.root.after_cancel(self.resize_job)&#10;        self.resize_job = self.root.after(200, self.perform_resize)&#10;&#10;    def perform_resize(self):&#10;        if self.display_image_cv2 is None: return&#10;        h, w = self.display_image_cv2.shape[:2]&#10;        self.canvas_width, self.canvas_height = self.canvas.winfo_width(), self.canvas.winfo_height()&#10;        if self.canvas_width &lt; 2 or self.canvas_height &lt; 2: return&#10;        self.scale_factor = min(self.canvas_width / w, self.canvas_height / h)&#10;        new_w, new_h = int(w * self.scale_factor), int(h * self.scale_factor)&#10;        if new_w &lt; 1 or new_h &lt; 1: return&#10;        img_resized = cv2.resize(self.display_image_cv2, (new_w, new_h))&#10;        self.current_image = Image.fromarray(img_resized)&#10;        self.photo = ImageTk.PhotoImage(self.current_image)&#10;        self.canvas.delete(&quot;all&quot;)&#10;        self.canvas.create_image(self.canvas_width // 2, self.canvas_height // 2, image=self.photo)&#10;        self.draw_all_bboxes()&#10;        if self.mode == 'rotation':&#10;            self.draw_crosshair_lines()&#10;&#10;    def load_classes(self):&#10;        if os.path.exists(&quot;classes.txt&quot;):&#10;            with open(&quot;classes.txt&quot;, 'r', encoding='utf-8') as f:&#10;                self.classes = [line.strip() for line in f.readlines() if line.strip()]&#10;        else:&#10;            self.classes = [&quot;person&quot;, &quot;car&quot;, &quot;bike&quot;, &quot;dog&quot;, &quot;cat&quot;]&#10;        self.update_class_radiobuttons()&#10;&#10;    def setup_classes(self):&#10;        class_window = tk.Toplevel(self.root)&#10;        class_window.title(&quot;클래스 설정&quot;)&#10;        text_widget = tk.Text(class_window, height=15)&#10;        text_widget.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)&#10;        text_widget.insert(tk.END, '\n'.join(self.classes))&#10;        def save_classes():&#10;            self.classes = [cls.strip() for cls in text_widget.get(1.0, tk.END).strip().split('\n') if cls.strip()]&#10;            with open(&quot;classes.txt&quot;, 'w', encoding='utf-8') as f: f.write('\n'.join(self.classes))&#10;            self.update_class_radiobuttons()&#10;            class_window.destroy()&#10;        tk.Button(class_window, text=&quot;저장&quot;, command=save_classes).pack(pady=5)&#10;&#10;    def update_class_radiobuttons(self):&#10;        for rb in self.class_radiobuttons: rb.destroy()&#10;        self.class_radiobuttons.clear()&#10;        self.calculate_class_frame_height()&#10;        if hasattr(self, 'canvas_frame'): self.canvas_frame.config(height=self.class_frame_height)&#10;        self.class_var.set(0)&#10;        for i, class_name in enumerate(self.classes):&#10;            rb = tk.Radiobutton(self.scrollable_frame, text=class_name, variable=self.class_var, value=i, indicatoron=0, anchor=&quot;w&quot;, command=self.on_class_selected)&#10;            rb.pack(fill=tk.X, padx=5, pady=2)&#10;            self.class_radiobuttons.append(rb)&#10;        if self.classes: self.current_class = 0&#10;        self.toggle_mode()&#10;&#10;    def on_class_selected(self, event=None): self.current_class = self.class_var.get()&#10;&#10;    def load_single_image(self):&#10;        if not self.check_unsaved_rotation(): return&#10;        file_path = filedialog.askopenfilename(filetypes=(('Image Files', '*.jpg *.jpeg *.png *.bmp'), ('All Files', '*.*')))&#10;        if file_path:&#10;            self.image_list = [file_path]&#10;            self.current_index = 0&#10;            self.load_current_image()&#10;&#10;    def load_images(self):&#10;        if not self.check_unsaved_rotation(): return&#10;        folder_path = filedialog.askdirectory()&#10;        if folder_path:&#10;            ext = ('.jpg', '.jpeg', '.png', '.bmp')&#10;            self.image_list = sorted([os.path.join(folder_path, f) for f in os.listdir(folder_path) if f.lower().endswith(ext)])&#10;            if self.image_list:&#10;                self.current_index = 0&#10;                self.load_current_image()&#10;                self.load_thumbnails()  # 추가: 썸네일 생성&#10;            else:&#10;                messagebox.showwarning(&quot;경고&quot;, &quot;이미지 파일을 찾을 수 없습니다.&quot;)&#10;&#10;    def load_current_image(self):&#10;        if not self.image_list: return&#10;        self.image_path = self.image_list[self.current_index]&#10;        img = cv2.imread(self.image_path)&#10;        if img is None:&#10;            messagebox.showerror(&quot;오류&quot;, f&quot;이미지를 읽을 수 없습니다: {self.image_path}&quot;)&#10;            return&#10;        self.original_image_cv2 = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)&#10;        self.display_image_cv2 = self.original_image_cv2.copy()&#10;        self.image_angle = 0&#10;        self.image_angle_float = 0.0&#10;        self.rotation_dirty = False&#10;        self.bboxes, self.bbox_rects = [], []&#10;        label_path = self.image_path.rsplit('.', 1)[0] + '.txt'&#10;        if os.path.exists(label_path):&#10;            with open(label_path, 'r') as f:&#10;                for line in f:&#10;                    parts = line.strip().split()&#10;                    if len(parts) == 5:&#10;                        self.bboxes.append(tuple(map(float, parts)))&#10;        self.perform_resize()&#10;        self.update_image_info()&#10;        self.update_label_list()&#10;&#10;    def load_thumbnails(self):&#10;        # 기존 썸네일 삭제&#10;        for lbl in self.thumb_labels:&#10;            lbl.destroy()&#10;        self.thumb_labels.clear()&#10;        self.thumbnails.clear()&#10;&#10;        for i, img_path in enumerate(self.image_list):&#10;            img = Image.open(img_path)&#10;            img.thumbnail((self.thumbnail_size, self.thumbnail_size))&#10;            thumb = ImageTk.PhotoImage(img)&#10;            self.thumbnails.append(thumb)  # 참조 유지 중요!&#10;&#10;            lbl = tk.Label(self.thumb_scrollable_frame, image=thumb, cursor=&quot;hand2&quot;, borderwidth=2, relief=&quot;groove&quot;)&#10;            lbl.pack(padx=5, pady=5)&#10;&#10;            def click_handler(event, idx=i):&#10;                if self.auto_save_enabled:&#10;                    if self.rotation_dirty:&#10;                        self.save_rotation()&#10;                    self.save_current_labels()&#10;                if not self.check_unsaved_rotation():&#10;                    return&#10;                self.current_index = idx&#10;                self.load_current_image()&#10;&#10;            lbl.bind(&quot;&lt;Button-1&gt;&quot;, click_handler)&#10;            self.thumb_labels.append(lbl)&#10;&#10;    def apply_rotation_and_redraw(self):&#10;        self.rotation_utils.apply_rotation_and_redraw()&#10;&#10;    def rotate_image_left(self):&#10;        self.rotation_utils.rotate_image_left()&#10;&#10;    def rotate_image_right(self):&#10;        self.rotation_utils.rotate_image_right()&#10;&#10;    def apply_smooth_rotation(self):&#10;        self.rotation_utils.apply_smooth_rotation()&#10;&#10;    def draw_all_bboxes(self):&#10;        self.labeling_utils.draw_all_bboxes()&#10;&#10;    def start_bbox(self, event):&#10;        self.labeling_utils.start_bbox(event)&#10;&#10;    def draw_bbox(self, event):&#10;        self.labeling_utils.draw_bbox(event)&#10;&#10;    def end_bbox(self, event):&#10;        self.labeling_utils.end_bbox(event)&#10;&#10;    def delete_bbox(self, event):&#10;        self.labeling_utils.delete_bbox(event)&#10;&#10;    def delete_selected_label(self, event):&#10;        self.labeling_utils.delete_selected_label(event)&#10;&#10;    def update_label_list(self):&#10;        self.label_listbox.delete(0, tk.END)&#10;        for i, (cid, xc, yc, w, h) in enumerate(self.bboxes):&#10;            c_name = self.classes[int(cid)] if int(cid) &lt; len(self.classes) else f&quot;Class{int(cid)}&quot;&#10;            self.label_listbox.insert(tk.END, f&quot;{i+1}. {c_name} ({w:.3f}x{h:.3f})&quot;)&#10;&#10;    def update_image_info(self):&#10;        text = f&quot;{self.current_index + 1}/{len(self.image_list)} - {os.path.basename(self.image_path)}&quot; if self.image_list else &quot;이미지 없음&quot;&#10;        self.image_info_label.config(text=text)&#10;&#10;    def prev_image(self):&#10;        if not self.check_unsaved_rotation(): return&#10;        if self.image_list and self.current_index &gt; 0:&#10;            if self.auto_save_enabled:&#10;                if self.rotation_dirty:&#10;                    self.save_rotation()&#10;                self.save_current_labels()&#10;            self.current_index -= 1&#10;            self.load_current_image()&#10;&#10;    def next_image(self):&#10;        if self.image_list and self.current_index &lt; len(self.image_list) - 1:&#10;            if self.auto_save_enabled:&#10;                if self.rotation_dirty:&#10;                    self.save_rotation()&#10;                # Save labels and remove txt file if no labels&#10;                if not self.bboxes:&#10;                    label_path = self.image_path.rsplit('.', 1)[0] + '.txt'&#10;                    if os.path.exists(label_path):&#10;                        os.remove(label_path)&#10;                else:&#10;                    self.save_current_labels()&#10;            self.current_index += 1&#10;            self.load_current_image()&#10;&#10;    def save_current_labels(self):&#10;        if not self.image_path or not self.bboxes:&#10;            return&#10;        label_path = self.image_path.rsplit('.', 1)[0] + '.txt'&#10;        with open(label_path, 'w') as f:&#10;            for cid, xc, yc, w, h in self.bboxes:&#10;                f.write(f&quot;{int(cid)} {xc:.6f} {yc:.6f} {w:.6f} {h:.6f}\n&quot;)&#10;&#10;    def save_changes(self):&#10;        if self.mode == 'rotation':&#10;            if self.rotation_dirty:&#10;                self.save_rotation()&#10;            else:&#10;                messagebox.showinfo(&quot;정보&quot;, &quot;회���된 내용이 없습니다.&quot;)&#10;        elif self.mode == 'labeling':&#10;            if not self.image_path:&#10;                messagebox.showwarning(&quot;경고&quot;, &quot;저장할 이미지가 없습니다.&quot;)&#10;                return&#10;            self.save_current_labels()&#10;&#10;    def calculate_class_frame_height(self):&#10;        self.class_frame_height = max(80, min(300, len(self.classes) * 30 + 20))&#10;&#10;    def toggle_auto_save(self): self.auto_save_enabled = self.auto_save_var.get()&#10;&#10;    def toggle_mode(self):&#10;        self.mode = self.mode_var.get()&#10;        is_rotation_mode = self.mode == 'rotation'&#10;&#10;        self.rotate_left_btn.config(state=tk.NORMAL if is_rotation_mode else tk.DISABLED)&#10;        self.rotate_right_btn.config(state=tk.NORMAL if is_rotation_mode else tk.DISABLED)&#10;&#10;        for rb in self.class_radiobuttons:&#10;            rb.config(state=tk.DISABLED if is_rotation_mode else tk.NORMAL)&#10;&#10;        self.canvas.config(cursor=&quot;arrow&quot; if is_rotation_mode else &quot;crosshair&quot;)&#10;&#10;        if is_rotation_mode:&#10;            self.draw_crosshair_lines()&#10;        else:&#10;            for line_id in self.crosshair_lines:&#10;                self.canvas.delete(line_id)&#10;            self.crosshair_lines.clear()&#10;&#10;&#10;    def on_canvas_button_press(self, event):&#10;        if self.mode == 'rotation':&#10;            self.drag_start_x = event.x&#10;            self.drag_start_y = event.y&#10;            self.start_angle = self.image_angle_float&#10;        elif self.mode == 'labeling':&#10;            self.start_bbox(event)&#10;&#10;    def on_canvas_mouse_drag(self, event):&#10;        if self.mode == 'rotation' and self.drag_start_x is not None:&#10;            delta_x = event.x - self.drag_start_x&#10;            sensitivity = 0.5  # 1픽셀당 0.5도 회전, 필요시 조절 가능&#10;            delta_angle = delta_x * sensitivity&#10;            new_angle = (self.start_angle + delta_angle) % 360&#10;            self.image_angle_float = new_angle&#10;            self.apply_smooth_rotation()&#10;        elif self.mode == 'labeling':&#10;            self.draw_bbox(event)&#10;&#10;    def on_canvas_button_release(self, event):&#10;        if self.mode == 'rotation' and self.drag_start_x is not None:&#10;            self.image_angle_float = self.image_angle_float % 360&#10;            self.image_angle = int(round(self.image_angle_float))&#10;            self.rotation_dirty = True&#10;            self.drag_start_x = None&#10;            self.drag_start_y = None&#10;            self.start_angle = 0.0&#10;        elif self.mode == 'labeling':&#10;            self.end_bbox(event)&#10;&#10;&#10;    def save_rotation(self):&#10;        img_to_save = cv2.cvtColor(self.display_image_cv2, cv2.COLOR_RGB2BGR)&#10;        try:&#10;            cv2.imwrite(self.image_path, img_to_save)&#10;            self.original_image_cv2 = self.display_image_cv2.copy()&#10;            self.rotation_dirty = False&#10;            self.image_angle = 0&#10;            self.image_angle_float = 0.0&#10;        except Exception as e:&#10;            messagebox.showerror(&quot;오류&quot;, f&quot;이미지 저장에 실패했습니다: {e}&quot;)&#10;&#10;    def check_unsaved_rotation(self):&#10;        if self.rotation_dirty:&#10;            response = messagebox.askyesnocancel(&quot;저장 확인&quot;, &quot;회전된 이미지가 저장되지 않았습니다. 저장하시겠습니까?&quot;)&#10;            if response is True:&#10;                self.save_rotation()&#10;                return True&#10;            elif response is False:&#10;                return True&#10;            else:&#10;                return False&#10;        return True&#10;&#10;    def draw_crosshair_lines(self):&#10;        if self.display_image_cv2 is None:&#10;            return&#10;        # 기존 보조선 삭제&#10;        for line_id in self.crosshair_lines:&#10;            self.canvas.delete(line_id)&#10;        self.crosshair_lines = []&#10;&#10;        w, h = self.canvas.winfo_width(), self.canvas.winfo_height()&#10;        center_x, center_y = w // 2, h // 2&#10;&#10;        # 가로/세로 파선 보조선 추가&#10;        h_line = self.canvas.create_line(0, center_y, w, center_y, fill='blue', dash=(4, 4))&#10;        v_line = self.canvas.create_line(center_x, 0, center_x, h, fill='blue', dash=(4, 4))&#10;&#10;        self.crosshair_lines.extend([h_line, v_line])&#10;&#10;    def set_mode_labeling(self):&#10;        self.mode_var.set('labeling')&#10;        self.toggle_mode()&#10;&#10;    def set_mode_rotation(self):&#10;        self.mode_var.set('rotation')&#10;        self.toggle_mode()&#10;&#10;def main():&#10;    root = tk.Tk()&#10;    app = YOLOLabeler(root)&#10;    root.mainloop()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.py" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/yolo_labeler.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/yolo_labeler.py" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>